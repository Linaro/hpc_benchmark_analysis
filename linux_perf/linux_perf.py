"""
 Linux Tools' Perf wrapper

 Usage:
  app = LinuxPerf(['myapp', '-flag', 'etc'])
  app.append_argument('-new_flag')
  repeat = 5
  events = ['cycles', 'cache-misses']
  app.stat(repeat, events)
  print app.cycles(),' +- ',app.cycles_stdev()
  print app.cache_misses()

 Plugin: parses the output of a specific benchmark, returns a dictionary
 with data to be used for statistics later, will be combined with the perf
 data
"""

import subprocess
import re

class PerfData:
    """All data generated by perf as well as external dictionary"""
    def __init__(self):
        # Hard-coded list of perf events plus other data it spews
        # well, the ones we support at least
        self.fields = {
            'instructions' : r'([\d,]+)\s+instructions',
            'cycles' : r'([\d,]+)\s+cycles',
            'cpu-migrations' : r'([\d,]+)\s+cpu-migrations',
            'context-switches' : r'([\d,]+)\s+context-switches',
            'page-faults' : r'([\d,]+)\s+page-faults',
            'branches' : r'([\d,]+)\s+branches',
            'branch-misses' : r'([\d,]+)\s+branch-misses',
            'elapsed' : r'(\d+\.\d+)\s+seconds time elapsed'
        }
        self.data = dict()
        self.ext = dict()
        self.raw = None
        self.name = ''

    def parse(self, results):
        """Parses the raw output, sets fields"""
        if isinstance(results, str):
            self.raw = results
        else:
            return None
        for field, regex in self.fields.items():
            match = re.search(regex, self.raw)
            if match:
                # hardcoded clear up, better to add this to fields
                self.data[field] = match.group(1).replace(',', '')
        return self.data

    def get_value(self, key):
        """ Get the value of an event or data"""
        if self.data and key in self.data:
            return self.data[key]
        if self.ext and key in self.ext:
            return self.ext[key]
        return ''

    def append(self, data):
        """Append external data"""
        if isinstance(data, dict):
            self.ext.update(data)

    def set_name(self, name):
        """Sets the log name"""
        if isinstance(name, str):
            self.name = name
        else:
            self.name = None

    def __str__(self):
        """Class name, for lists"""
        return "PerfData: " + self.name

    def __repr__(self):
        """Pretty-printing"""
        string = "[ PerfData (" + self.name + "): "
        string += repr(len(self.fields)) + " fields, "
        string += repr(len(self.data)) + " perf data, "
        string += repr(len(self.ext)) + " ext data ]"
        return string

class LinuxPerf:
    """Main class, calls perf stat with some options, saves output for plugins
       to analyse, parses and stores the perf data in the object for later
       enquiry.
    """
    def __init__(self, program=None, plugin=None):
        # list of arguments
        self.program = list()
        if isinstance(program, list) and program:
            self.program.extend(program)
        # external plugin, benchmark specific
        self.plugin = plugin
        # list of events
        self.events = list()
        # gathered data by perf and benchmark plugin
        self.data = PerfData()
        # raw output / stderr (perfdata)
        self.output = None
        self.perfdata = None

    def append_argument(self, argument):
        """Appends argument(s) to the program list"""
        if isinstance(argument, list):
            self.program.extend(argument)
        else:
            self.program.append(argument)

    def stat(self, repeat=1, events=None):
        """Runs perf stat on the process, saving the output"""
        call = ['perf', 'stat']
        # Repeat the run N times, reports stdev
        if repeat > 1:
            call.extend(['-r', repeat])
        # Collects only a few events (empty = all)
        if isinstance(events, list):
            self.events.extend(events)
        if self.events:
            call.append('-e')
            ev_str = ''
            for event in self.events:
                ev_str += event
                ev_str += ','
            ev_str.pop()
            print(ev_str)
            call.append(ev_str)
        # Adding program to perf
        call.extend(self.program)
        # Call and collect output
        result = subprocess.run(call, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        self.output = result.stdout.decode('utf-8')
        self.perfdata = result.stderr.decode('utf-8')

    def parse(self):
        """Parses the output of perf stat"""
        # First, parses the output for the plugin to fill in its own data
        if self.plugin:
            results = self.plugin.parse(self.output)
            self.data.append(results)
        # Now, parses the perf output
        self.data.parse(self.perfdata)
        return self.data

    def get_value(self, key):
        """Gets a key from PerfData"""
        return self.data.get_value(key)

    def get_raw(self):
        """Gets raw results from out and err"""
        return self.output + self.perfdata

    def set_raw(self, raw):
        """Sets raw results onto both out and err"""
        self.output = raw
        self.perfdata = raw

    def __str__(self):
        """Class name, for lists"""
        return "LinuxPerf"

    def __repr__(self):
        """Pretty-printing"""
        string = "[ "
        if self.program:
            string += repr(self.program) + ": "
        else:
            string += "<raw>: "
        if self.plugin:
            string += repr(self.plugin) + ", "
        else:
            string += "<no plugin>, "
        string += repr(self.data) + ", "
        string += repr(len(self.events)) + " events ]"
        return string
