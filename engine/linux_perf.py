"""
 Linux Tools' Perf wrapper

 Usage:
  app = LinuxPerf(['myapp', '-flag', 'etc'])
  app.append_argument('-new_flag')
  repeat = 5
  events = ['cycles', 'cache-misses']
  app.stat(repeat, events)
  print app.cycles(),' +- ',app.cycles_stdev()
  print app.cache_misses()

 Plugin: parses the output of a specific benchmark, returns a dictionary
 with data to be used for statistics later, will be combined with the perf
 data
"""

import subprocess
import re
from pathlib import Path
import shutil

class LinuxPerfPluginBase:
    """Base class for all linux_perf plugins"""
    def __init__(self):
        self.data = dict()
        self.fields = None
        self.raw = None

    def parse(self, results):
        """Parses the raw output, sets fields"""
        self.data.clear()
        if not results:
            return self.data

        if not isinstance(results, str):
            raise TypeError("Parseable results must be string")

        self.raw = results
        for field, regex in self.fields.items():
            match = re.search(regex, self.raw)
            if match:
                # hardcoded clear up, better to add this to fields
                self.data[field] = match.group(1).replace(',', '')

        return self.data

    def get_value(self, key):
        """ Get the value from data"""
        if self.data and key in self.data:
            return self.data[key]
        return 0

class PerfData(LinuxPerfPluginBase):
    """All data generated by perf as well as external dictionary"""
    def __init__(self):
        super().__init__()
        # Hard-coded list of perf events plus other data it spews
        # well, the ones we support at least
        self.fields = {
            'instructions' : r'([\d,]+)\s+instructions',
            'cycles' : r'([\d,]+)\s+cycles',
            'cpu-migrations' : r'([\d,]+)\s+cpu-migrations',
            'context-switches' : r'([\d,]+)\s+context-switches',
            'page-faults' : r'([\d,]+)\s+page-faults',
            'branches' : r'([\d,]+)\s+branches',
            'branch-misses' : r'([\d,]+)\s+branch-misses',
            'elapsed' : r'(\d+\.\d+)\s+seconds time elapsed'
        }
        # This plugin aggregates results from all other plugins
        self.ext = dict()

    def get_value(self, key):
        """ Get the value from data or ext"""
        value = super().get_value(key)
        if not value and key in self.ext:
            return self.ext[key]
        return value

    def set_name(self, name):
        """Adds a dictionary item 'name' with the name"""
        if not isinstance(name, str):
            raise TypeError("Name must be string")
        self.data['name'] = name

    def append(self, data):
        """Append external data"""
        if not isinstance(data, dict):
            raise TypeError("External data must be dictionary")
        self.ext.clear()
        self.ext.update(data)

    def __str__(self):
        """Class name, for lists"""
        return "PerfData"

    def __repr__(self):
        """Pretty-printing"""
        string = "[ PerfData: "
        string += repr(len(self.fields)) + " fields, "
        string += repr(len(self.data)) + " perf data, "
        string += repr(len(self.ext)) + " ext data ]"
        return string

class LinuxPerf:
    """Main class, calls perf stat with some options, saves output for plugins
       to analyse, parses and stores the perf data in the object for later
       enquiry.
    """
    def __init__(self, program=None, plugin=None):
        # list of arguments
        self.program = list()
        if isinstance(program, list) and program:
            self.program.extend(program)
        # external plugin, benchmark specific
        self.plugin = plugin
        # list of events
        self.events = list()
        # gathered data by perf and benchmark plugin
        self.data = PerfData()
        # raw output / stderr (perfdata)
        self.output = None
        self.perfdata = None

    def append_argument(self, argument):
        """Appends argument(s) to the program list"""
        if isinstance(argument, list):
            self.program.extend(argument)
        else:
            self.program.append(argument)

    def perf_command(self):
        # Verify that perf is actually installed
        command = shutil.which('perf')
        if not command:
            raise RuntimeError("Perf is not installed")
        # Check that you have permissions to do anything
        CAP_SYS_ADMIN = Path('/proc/sys/kernel/perf_event_paranoid').read_text()
        if int(CAP_SYS_ADMIN) >= 3:
            raise RuntimeError("Can't run perf with CAP_SYS_ADMIN higher than 2")
        return command

    def stat(self, repeat=1, events=None):
        """Runs perf stat on the process, saving the output"""
        call = [self.perf_command(), 'stat']
        # Repeat the run N times, reports stdev
        if repeat > 1:
            call.extend(['-r', repeat])
        # Collects only a few events (empty = all)
        if isinstance(events, list):
            self.events.extend(events)
        if self.events:
            call.append('-e')
            ev_str = ''
            for event in self.events:
                ev_str += event
                ev_str += ','
            ev_str.pop()
            print(ev_str)
            call.append(ev_str)
        # Adding program to perf
        call.extend(self.program)
        # Call and collect output
        result = subprocess.run(call, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        self.output = result.stdout.decode('utf-8')
        self.perfdata = result.stderr.decode('utf-8')

    def parse(self, out=None, err=None):
        """Parses the output of perf stat / external output"""
        # Finds the right output/err to parse from (arguments have priority)
        if out is not None:
            if not isinstance(out, str):
                raise TypeError("Output must be a string")
            self.output = out
        if err is not None:
            if not isinstance(err, str):
                raise TypeError("Perfdata must be a string")
            self.perfdata = err
        if not self.output and not self.perfdata:
            raise ValueError("No output/perfdata to parse")

        # Parses the output with the plugin (benchmark results)
        if self.plugin:
            results = self.plugin.parse(self.output)
            self.data.append(results)

        # Parses the stderr buffer (linux perf output)
        self.data.parse(self.perfdata)
        return self.data

    def get_value(self, key):
        """Gets a key from PerfData"""
        return self.data.get_value(key)

    def get_raw(self):
        """Gets (unscrambled) raw results from out and err"""
        raw = self.output
        if raw:
            raw += self.perfdata
        else:
            raw = self.perfdata
        return raw

    def __str__(self):
        """Class name, for lists"""
        return "LinuxPerf"

    def __repr__(self):
        """Pretty-printing"""
        string = "[ "
        if self.program:
            string += repr(self.program) + ": "
        else:
            string += "<raw>: "
        if self.plugin:
            string += repr(self.plugin) + ", "
        else:
            string += "<no plugin>, "
        string += repr(self.data) + ", "
        string += repr(len(self.events)) + " events ]"
        return string
